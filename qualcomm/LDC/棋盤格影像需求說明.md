# 棋盤格影像需求說明

## 1. 棋盤格的基本定義

`cv2.findChessboardCorners()` 偵測的是棋盤格的**內角點 (inner corners)**，不是棋盤格本身的格子數。

### 格點數計算
- 若棋盤格有 **N×M 個黑白方格**（視覺上的格子數）
- 則內角點數為 **(N-1) × (M-1)**

**例：**
- 9×9 棋盤 → 8×8 = 64 個內角點
- 10×7 棋盤 → 9×6 = 54 個內角點（常見的 (9,6) pattern_size 對應此規格）

## 2. 影像質量要求

### 2.1 對比度 (Contrast)
- **必需：** 黑白區塊間有**明顯對比**
  - 白色區塊應接近 **RGB(255, 255, 255)** 或很亮（例如 >200）
  - 黑色區塊應接近 **RGB(0, 0, 0)** 或很暗（例如 <50）
- **問題：** 灰色棋盤、顏色棋盤、低對比度 → 角點偵測失敗

### 2.2 清晰度 / 銳度 (Sharpness)
- **必需：** 黑白邊界**銳利、清晰**，無模糊或毛邊
- **問題：** 
  - 影像模糊（對焦不清）→ 角點邊界不明確 → 偵測失敗
  - 運動模糊 → 邊界拖尾 → 偵測失敗
- **建議：** 固定相機或使用高快門速度拍攝，確保影像清晰

### 2.3 照明均勻性 (Uniform Lighting)
- **必需：** 棋盤整個表面照度**均勻**，避免陰影或亮點
- **問題：** 
  - 一角過亮/過暗 → 對比度不均勻 → 部分區域偵測失敗
  - 不規則陰影 → 角點位置判定不準
- **建議：** 
  - 使用柔和、均勻的照明（如漫射光或多角度光源）
  - 避免直射光或單點照源

### 2.4 平面性 (Planarity)
- **必需：** 棋盤應**平整**，無褶皺、彎曲或凹凸
- **問題：** 
  - 棋盤歪曲或立體 → 角點無法排成規則網格 → 偵測失敗
- **建議：** 棋盤應貼在硬質、平的背景上

### 2.5 解析度 (Resolution)
- **必需：** 每個棋盤格應至少佔用 **5~10 像素**
- **問題：** 
  - 影像太小，棋盤格只有 2~3 像素 → 角點邊界不清晰
  - 無法精確定位角點位置
- **建議：** 
  - 如果相機 FOV 很大，靠近棋盤拍攝，或使用更大的棋盤
  - 確保棋盤佔影像面積至少 **20~80%**

### 2.6 畸變與失焦 (Distortion)
- **注意：** 在校準過程中，棋盤會出現輕微的透視變形（這是正常的）
- **問題：** 過度桶形或枕形失真（鏡頭本身的失真）會使角點難以偵測
- **建議：** 在棋盤相對居中、直視的位置拍攝（避免極端斜角）

---

## 3. 程式中的 pattern_size 設定

### pattern_size 的含義
```python
pattern_size = (cols, rows)  # (內角點列數, 內角點行數)
```

### 常見設定
| 棋盤格規格 | pattern_size | 說明 |
|-----------|-------------|------|
| 9×7 棋盤  | (8, 6)      | 8 列 × 6 行 = 48 個內角點 |
| 10×8 棋盤 | (9, 7)      | 9 列 × 7 行 = 63 個內角點 |
| 10×7 棋盤 | **(9, 6)**  | **最常見**，54 個內角點 |
| 12×9 棋盤 | (11, 8)     | 11 列 × 8 行 = 88 個內角點 |
| 13×10 棋盤 | (12, 9)    | 12 列 × 9 行 = 108 個內角點 |

### 如何選擇 pattern_size
1. **確認實體棋盤的規格** （數一下黑白方格，例如 9×7）
2. **計算內角點數** = (列數 - 1) × (行數 - 1)
3. **設定程式中的 pattern_size** = (列數 - 1, 行數 - 1)

**例子：**
- 你的棋盤有 10 列、7 行黑白格 → pattern_size = (9, 6)
- 你的棋盤有 13 列、10 行黑白格 → pattern_size = (12, 9)

---

## 4. 偵測失敗時的診斷方法

若 `cv2.findChessboardCorners()` 回傳 False，可逐步檢查：

### 4.1 檢查影像是否正確載入
```python
img = cv2.imread(img_path)
if img is None:
    print("影像載入失敗")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
print(f"影像尺寸: {gray.shape}")  # (高, 寬)
```

### 4.2 檢查對比度
```python
import matplotlib.pyplot as plt
plt.imshow(gray, cmap='gray')
plt.title("灰度影像")
plt.show()
# 觀察黑白邊界是否清晰，有無陰影或過曝
```

### 4.3 嘗試調整偵測參數
```python
# 添加自適應偵測標誌
flags = cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE
ret, corners = cv2.findChessboardCorners(gray, pattern_size, flags)

# 若仍失敗，嘗試其他組合
flags = cv2.CALIB_CB_FILTER_QUADS | cv2.CALIB_CB_FAST_CHECK
ret, corners = cv2.findChessboardCorners(gray, pattern_size, flags)
```

### 4.4 驗證 pattern_size
```python
# 嘗試多個常見的 pattern_size
for cols, rows in [(8, 6), (9, 6), (9, 7), (11, 8), (12, 9)]:
    ret, corners = cv2.findChessboardCorners(gray, (cols, rows), flags)
    if ret:
        print(f"偵測成功！pattern_size = ({cols}, {rows}), 角點數 = {len(corners)}")
        break
```

---

## 5. 優化程式中的角點偵測

### 5.1 增強錯誤訊息
```python
def calculate_distortion(img_path, pattern_size, square_size_mm):
    img = cv2.imread(img_path)
    if img is None:
        raise FileNotFoundError(f"無法讀取文件: {img_path}")

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    h, w = gray.shape[:2]
    
    cols, rows = pattern_size
    
    # 嘗試標準偵測
    flags = cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE
    ret, corners = cv2.findChessboardCorners(gray, pattern_size, flags)
    
    if not ret:
        # 提供更詳細的診斷訊息
        print(f"[診斷] 無法偵測到 {cols} x {rows} 的棋盤格")
        print(f"[診斷] 影像尺寸: {w} × {h}")
        print(f"[診斷] 灰度範圍: min={gray.min()}, max={gray.max()}, mean={gray.mean():.1f}")
        
        # 嘗試替代 pattern_size
        print(f"[嘗試] 測試其他 pattern_size...")
        for alt_cols, alt_rows in [(8, 6), (9, 7), (11, 8)]:
            ret_alt, corners_alt = cv2.findChessboardCorners(gray, (alt_cols, alt_rows), flags)
            if ret_alt:
                print(f"[成功] 改用 ({alt_cols}, {alt_rows}) 偵測成功")
                cols, rows, corners = alt_cols, alt_rows, corners_alt
                ret = True
                break
    
    if not ret:
        raise ValueError(
            f"無法成功檢測到 {cols} x {rows} 的棋盤格角點。\n"
            "請檢查:\n"
            "  1. 影像是否包含清晰的棋盤格\n"
            "  2. 棋盤格的黑白對比是否足夠高\n"
            "  3. pattern_size 是否正確（與實體棋盤格數相符）\n"
            "  4. 影像是否有模糊、陰影或畸變\n"
            f"  5. 每個棋盤格是否至少 5 像素以上\n"
        )
    
    # 其餘程式碼...
```

### 5.2 偵測前的影像預處理（可選）
```python
# 若影像對比度不足，可嘗試直方圖均衡化
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.equalizeHist(gray)  # 增強對比度

# 或使用 CLAHE (對比度受限的自適應直方圖均衡化)
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
gray = clahe.apply(gray)

ret, corners = cv2.findChessboardCorners(gray, pattern_size, flags)
```

---

## 6. 推薦的棋盤格來源

- **OpenCV 官方提供的棋盤格模板：** 
  - https://docs.opencv.org/4.x/da/d0d/tutorial_camera_calibration_pattern.html
  - 標準 9×6 或 8×6 的 PDF 模板可下載列印

- **自製棋盤格：**
  - 使用開源工具（如 Calib.io、PatternOnTheFly）生成 PDF
  - 列印到 A4 或更大尺寸紙張，確保對比度高
  - 建議列印品質：黑色應接近 100% K（純黑），白色應為紙張本白

---

## 7. 實務建議總結

| 方面 | 要求 | 檢查方法 |
|------|------|---------|
| **棋盤格規格** | 確認實體棋盤格數，設定對應的 pattern_size | 數一下黑白格子個數 |
| **對比度** | 黑白邊界清晰銳利 | 用肉眼或影像查看器觀察 |
| **照明** | 均勻，無陰影或亮點 | 觀察灰度影像，顏色分佈是否均勻 |
| **清晰度** | 銳利，無模糊 | 放大檢視，棋盤邊界應清晰 |
| **平面性** | 棋盤平整，無褶皺 | 檢查棋盤是否貼緊平面背景 |
| **尺寸** | 棋盤在影像中佔 20~80% | 調整相機距離或使用更大棋盤 |
| **格子大小** | 每格至少 5~10 像素 | 計算：(影像寬度 / 格子列數) ≥ 5 |

---

## 8. 常見失敗案例與解決方案

| 失敗現象 | 原因 | 解決方案 |
|--------|------|---------|
| 總是偵測不到 | pattern_size 錯誤 | 數一下實體棋盤格，重新計算 pattern_size |
| 部分圖片成功，部分失敗 | 照明不均或棋盤歪曲 | 改善光線，確保棋盤平整 |
| 影像清晰但仍失敗 | 對比度不足 | 調整曝光或使用直方圖均衡化 |
| pattern_size 設定對但偵測失敗 | 棋盤格規格實際不符 | 確認實體棋盤，可能規格不是預期的 |
| 邊緣角點偵測不到 | 棋盤邊界超出影像範圍 | 確保棋盤完整且在影像內 |

---

## 總結：快速檢查清單

在執行 `calculate_distortion()` 前，確保：

- [ ] **實體棋盤規格已確認** （例如 9×7 格子）
- [ ] **pattern_size 已設定正確** （9×7 棋盤 → pattern_size = (8, 6)）
- [ ] **影像清晰銳利** （無模糊或運動模糊）
- [ ] **黑白對比明顯** （黑應接近 RGB(0,0,0)，白應接近 RGB(255,255,255)）
- [ ] **照明均勻** （無強烈陰影或過曝）
- [ ] **棋盤完整** （所有格子和邊界都在影像範圍內）
- [ ] **棋盤平整** （無褶皺或彎曲）
- [ ] **格子尺寸足夠大** （每格至少 5 像素）

滿足以上條件，`cv2.findChessboardCorners()` 應能成功偵測到所有內角點。
